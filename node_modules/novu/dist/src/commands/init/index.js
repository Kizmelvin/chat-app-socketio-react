"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.init = void 0;
const picocolors_1 = require("picocolors");
const path_1 = __importDefault(require("path"));
const prompts_1 = __importDefault(require("prompts"));
const create_app_1 = require("./create-app");
const validate_pkg_1 = require("./helpers/validate-pkg");
const is_folder_empty_1 = require("./helpers/is-folder-empty");
const fs_1 = __importDefault(require("fs"));
const analytics_service_1 = require("../../services/analytics.service");
const analytics = new analytics_service_1.AnalyticService();
const programName = 'novu init';
const onPromptState = (state) => {
    if (state.aborted) {
        process.stdout.write('\x1B[?25h');
        process.stdout.write('\n');
        process.exit(1);
    }
};
async function init(program, anonymousId) {
    var _a;
    if (anonymousId) {
        analytics.track({
            identity: {
                anonymousId: anonymousId,
            },
            data: {},
            event: 'Run Novu Init Command',
        });
    }
    let projectPath = program.projectPath;
    if (typeof projectPath === 'string') {
        projectPath = projectPath.trim();
    }
    if (!projectPath) {
        const res = await (0, prompts_1.default)({
            onState: onPromptState,
            type: 'text',
            name: 'path',
            message: 'What is your project named?',
            initial: 'my-novu-app',
            validate: (name) => {
                const validation = (0, validate_pkg_1.validateNpmName)(path_1.default.basename(path_1.default.resolve(name)));
                if (validation.valid) {
                    return true;
                }
                return 'Invalid project name: ' + validation.problems[0];
            },
        });
        if (typeof res.path === 'string') {
            projectPath = res.path.trim();
        }
    }
    if (!projectPath) {
        console.log('\nPlease specify the project directory:\n' +
            `  ${(0, picocolors_1.cyan)(programName)} ${(0, picocolors_1.green)('<project-directory>')}\n` +
            'For example:\n' +
            `  ${(0, picocolors_1.cyan)(programName)} ${(0, picocolors_1.green)('my-novu-app')}\n\n` +
            `Run ${(0, picocolors_1.cyan)(`${programName} --help`)} to see all options.`);
        process.exit(1);
    }
    const resolvedProjectPath = path_1.default.resolve(projectPath);
    const projectName = path_1.default.basename(resolvedProjectPath);
    const validation = (0, validate_pkg_1.validateNpmName)(projectName);
    if (!validation.valid) {
        console.error(`Could not create a project called ${(0, picocolors_1.red)(`"${projectName}"`)} because of npm naming restrictions:`);
        validation.problems.forEach((problem) => console.error(`    ${(0, picocolors_1.red)((0, picocolors_1.bold)('*'))} ${problem}`));
        process.exit(1);
    }
    let userId;
    if (!program.secretKey) {
        program.secretKey = '';
    }
    else {
        try {
            const response = await fetch(program.apiUrl + '/v1/users/me', {
                headers: {
                    Authorization: `ApiKey ${program.secretKey}`,
                },
            });
            if (!response.ok) {
                throw new Error('Failed to fetch api key details');
            }
            const user = await response.json();
            userId = (_a = user.data) === null || _a === void 0 ? void 0 : _a._id;
            analytics.alias({
                previousId: anonymousId,
                userId,
            });
        }
        catch (error) {
            console.error(`Failed to verify your secret key against ${program.apiUrl}. For EU instances use --api-url https://eu.novu.co or provide the correct secret key`);
            process.exit(1);
        }
    }
    const root = path_1.default.resolve(resolvedProjectPath);
    const appName = path_1.default.basename(root);
    const folderExists = fs_1.default.existsSync(root);
    if (folderExists && !(0, is_folder_empty_1.isFolderEmpty)(root, appName)) {
        console.error("The supplied project directory isn't empty, please provide an empty or non existing directory.");
        process.exit(1);
    }
    const preferences = {};
    const defaults = {
        typescript: true,
        eslint: true,
        app: true,
        srcDir: false,
        importAlias: '@/*',
        customizeImportAlias: false,
    };
    if (userId || anonymousId) {
        analytics.track({
            identity: userId ? { userId } : { anonymousId },
            data: {
                name: projectName,
            },
            event: 'Creating a new project',
        });
    }
    await (0, create_app_1.createApp)({
        appPath: resolvedProjectPath,
        packageManager: 'npm',
        typescript: defaults.typescript,
        eslint: defaults.eslint,
        srcDir: defaults.srcDir,
        importAlias: defaults.importAlias,
        secretKey: program.secretKey,
    });
    if (userId || anonymousId) {
        analytics.track({
            identity: userId ? { userId } : { anonymousId },
            data: {
                name: projectName,
            },
            event: 'Project created',
        });
    }
}
exports.init = init;
