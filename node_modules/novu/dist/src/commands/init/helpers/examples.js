"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadAndExtractExample = exports.downloadAndExtractRepo = exports.existsInRepo = exports.hasRepo = exports.getRepoInfo = exports.isUrlOk = void 0;
const tar_1 = __importDefault(require("tar"));
const stream_1 = require("stream");
const promises_1 = require("stream/promises");
async function isUrlOk(url) {
    try {
        const res = await fetch(url, { method: 'HEAD' });
        return res.status === 200;
    }
    catch (_a) {
        return false;
    }
}
exports.isUrlOk = isUrlOk;
async function getRepoInfo(url, examplePath) {
    const [, username, name, t, _branch, ...file] = url.pathname.split('/');
    const filePath = examplePath ? examplePath.replace(/^\//, '') : file.join('/');
    if (t === undefined ||
        (t === '' && _branch === undefined)) {
        try {
            const infoResponse = await fetch(`https://api.github.com/repos/${username}/${name}`);
            if (infoResponse.status !== 200) {
                return;
            }
            const info = await infoResponse.json();
            return { username, name, branch: info['default_branch'], filePath };
        }
        catch (_a) {
            return;
        }
    }
    const branch = examplePath ? `${_branch}/${file.join('/')}`.replace(new RegExp(`/${filePath}|/$`), '') : _branch;
    if (username && name && branch && t === 'tree') {
        return { username, name, branch, filePath };
    }
}
exports.getRepoInfo = getRepoInfo;
function hasRepo({ username, name, branch, filePath }) {
    const contentsUrl = `https://api.github.com/repos/${username}/${name}/contents`;
    const packagePath = `${filePath ? `/${filePath}` : ''}/package.json`;
    return isUrlOk(contentsUrl + packagePath + `?ref=${branch}`);
}
exports.hasRepo = hasRepo;
function existsInRepo(nameOrUrl) {
    try {
        const url = new URL(nameOrUrl);
        return isUrlOk(url.href);
    }
    catch (_a) {
        return isUrlOk(`https://api.github.com/repos/vercel/next.js/contents/examples/${encodeURIComponent(nameOrUrl)}`);
    }
}
exports.existsInRepo = existsInRepo;
async function downloadTarStream(url) {
    const res = await fetch(url);
    if (!res.body) {
        throw new Error(`Failed to download: ${url}`);
    }
    return stream_1.Readable.fromWeb(res.body);
}
async function downloadAndExtractRepo(root, { username, name, branch, filePath }) {
    await (0, promises_1.pipeline)(await downloadTarStream(`https://codeload.github.com/${username}/${name}/tar.gz/${branch}`), tar_1.default.x({
        cwd: root,
        strip: filePath ? filePath.split('/').length + 1 : 1,
        filter: (p) => p.startsWith(`${name}-${branch.replace(/\//g, '-')}${filePath ? `/${filePath}/` : '/'}`),
    }));
}
exports.downloadAndExtractRepo = downloadAndExtractRepo;
async function downloadAndExtractExample(root, name) {
    if (name === '__internal-testing-retry') {
        throw new Error('This is an internal example for testing the CLI.');
    }
    await (0, promises_1.pipeline)(await downloadTarStream('https://codeload.github.com/vercel/next.js/tar.gz/canary'), tar_1.default.x({
        cwd: root,
        strip: 2 + name.split('/').length,
        filter: (p) => p.includes(`next.js-canary/examples/${name}/`),
    }));
}
exports.downloadAndExtractExample = downloadAndExtractExample;
